# 缠论各元素识别规则及绘制方法 v1.3

## 文档更新说明

- **key point 本版统一术语为“合并K线”**（即去包含后的K线），不再使用“HL柱”的称谓。新增“合并K线”专章：基于v1.0需求，补充合并K线的详细算法逻辑、数据结构、字段定义与处理规则。
- **key point 分型的一般规则允许强分型、标准分型、弱分型之间共用合并K线**（即同一根合并K线可以同时参与多个分型的三根结构）。
- **key point 确认分型规则保持严格**：确认分型必须由连续六根合并K线组成两个相邻的同向分型，两个分型之间既不能重叠（不可共用合并K线），也不能相离（中间不可夹独立合并K线）。
- **key point 确认分型的极值比较采用严格不等**：同为顶分时，第一组的中柱最高点严格高于第二组的中柱最高点，且第一组右柱最高点严格高于第二组左柱最高点；同为底分时，第一组的中柱最低点严格低于第二组的中柱最低点，且第一组右柱最低点严格低于第二组左柱最低点。
- **key point 显著度门槛预留但默认不启用**：最小价差与最小百分比门槛的设置项保留，当前默认为零，不参与筛选。
- **key point v1.2 更新：补全“线段内部缺口（rev_pens_gap_bool）”**：特征序列包含关系消解 + 最右两有效特征序列判定（闭区间重叠含端点接触；完全相离为缺口）。
- **key point v1.3 更新：补全“元线段连接规则”**：在同一连续岛内，将断裂的元线段片段按规则连接成完整的线段折线；并与“只要完成连接立即对前段做内部缺口判断”的原则一致，不重复叙述。

---

## 合并K线（处理包含关系）

### 0. 定义、目的与使用边界

- 定义：合并K线是将相邻K线之间的包含/重叠关系按规则消解后得到的“精简K线序列”。每根合并K线仅保留该根的覆盖范围与极值来源索引，并附带方向属性（上涨/下跌）。
- 目的：以更少但更结构化的关键转折点替代原始K线中的随机噪声，为后续“分型→笔→线段→中枢”等识别提供稳定输入。
- **key point 唯一基准**：后续所有识别与绘制均以合并K线为唯一基准，不回看原始K线的高低、根数或形态（除“连续性分岛”属于工程层面的结构切分外）。

### 1. 输入/输出契约（工程接口）

#### 1.1 输入（原始K线 candles）

- candles: Array<{ ts:number, o:number, h:number, l:number, c:number, ... }>
- 时间字段唯一真相源：ts（毫秒时间戳，Unix epoch ms）。
- 价格字段唯一真相源：candles[i].h / candles[i].l（以及 o/c 等）。

#### 1.2 输出（合并K线 reducedBars）

- reducedBars: Array<ReducedBar>
**key point 工程对齐：ReducedBar 为 Idx-Only（禁止存 ts/pri）**

ReducedBar 字段（当前工程实现对齐）：

- start_idx_orig: number  
  含义：该合并K线覆盖的原始K线起始索引（含）。
- end_idx_orig: number  
  含义：该合并K线覆盖的原始K线结束索引（含）。
- g_idx_orig: number  
  含义：该合并K线“最高点来源”的原始K线索引。  
  价格读取：High = candles[g_idx_orig].h。
- d_idx_orig: number  
  含义：该合并K线“最低点来源”的原始K线索引。  
  价格读取：Low = candles[d_idx_orig].l。
- dir_int: number  
  含义：方向：+1=上涨；-1=下跌；0=尚未能确定方向（只可能出现在某个连续岛开端）。
- seq_id: number  
  含义：连续岛编号（从 1 起）。合并K线不跨岛合并。
- barrier_after_prev_bool: boolean  
  含义：该合并K线是否为“屏障后的首根”。
- gap_enum: 'up' | 'down' | 'none'  
  含义：相对上一根合并K线的“跳空缺口状态”（几何判定）：
  - 'up'：上一根 High < 当前根 Low（价格区间严格不重叠且上跳空）
  - 'down'：上一根 Low > 当前根 High（价格区间严格不重叠且下跳空）
  - 'none'：其余情况（有交叠/贴边/无缺口）
  - **key point 记录位置**：缺口记录在“后一根”合并K线上（当前根）。

#### 1.3 输出（原始K到合并K的映射 mapOrigToReduced）

- mapOrigToReduced: Array<MapEntry | undefined>

MapEntry 字段（工程对齐）：

- reduced_idx: number  
  含义：该原始K线归属的合并K线索引（即 reducedBars 的数组下标）。
- role_str: 'carrier' | 'merged'  
  含义：
  - carrier：该原始K线是当前合并K线的“代表/承载”位置（工程用于定位/tooltip映射等）
  - merged：该原始K线被包含合并到同一根合并K线中
- seq_id: number  
  含义：该原始K线所属连续岛编号。

#### 1.4 输出（meta）

- meta.algo: string（如 include_v1）
- meta.anchorPolicy: 'right' | 'extreme'（仅元信息）
- meta.generated_at: string（仅元信息/展示用途，不参与计算）

### 2. 算法流程（简洁可执行版）

整体处理顺序：从左到右单向扫描，不允许反向回看、不允许跳跃。

设 a 为“最新合并K线”，b 为“当前扫描到的原始K线（或被包装成临时合并K线的候选）”。

步骤：

1) 连续岛切分（seq_id）

- 若当前索引 i 为屏障点（或 i==0），开启新岛：seq_id++，lastDir 清零。
- **key point 不跨岛合并**：新岛首根直接作为一根新的合并K线，不与前岛末根发生包含合并。

1) 严格上涨/严格下跌判定（完全分类的第一层）

- 严格上涨（趋势推进）：
  - a.High < b.High 且 a.Low < b.Low
  - 结论：b 作为新合并K线追加到序列，b.dir_int = +1。
- 严格下跌（趋势推进）：
  - a.High > b.High 且 a.Low > b.Low
  - 结论：b 作为新合并K线追加到序列，b.dir_int = -1。
- 其余情况：
  - **key point 一律视作存在包含/重叠关系**，进入“包含合并”分支。

> 注：High/Low 均通过 g_idx_orig/d_idx_orig 回溯 candles 读取；合并K线本体不存价格字段。

1) 包含合并（依据当前趋势方向决定“高高/低低”）

- 若当前趋势为上涨（dir_int >= 0）：
  - newHigh = max(a.High, b.High)
  - newLow  = max(a.Low,  b.Low)
- 若当前趋势为下跌（dir_int < 0）：
  - newHigh = min(a.High, b.High)
  - newLow  = min(a.Low,  b.Low)
- 同步维护极值来源：
  - 若 newHigh 来自 b，则更新 a.g_idx_orig = i；
  - 若 newLow  来自 b，则更新 a.d_idx_orig = i；
- 合并后，更新 a.end_idx_orig 并刷新 mapOrigToReduced 的覆盖区间映射。

### 3. 趋势方向的确定（重心兜底：每岛开端允许）

合并分支需要“当前趋势”（上涨/下跌）以决定用高高或低低。趋势来源规则：

- 若 a.dir_int 已确定（±1），优先使用。
- 若岛内尚未形成趋势（a.dir_int==0 且 lastDir==0 且缺乏可参考的前序关系）：
  - **key point 使用重心兜底**：比较 (High+Low) 的变化方向来决定上涨/下跌（等价于比较重心 (H+L)/2 的变化，不必真实除以2）。
  - 该兜底只在“本岛尚无明确趋势”时触发��一旦岛内出现严格上涨/严格下跌推进，后续都将以趋势推进产生的 dir_int/lastDir 为主，不再依赖重心兜底。

备注：极端小概率情形（两根相互包含且重心相等）可按工程默认策略（如偏向 +1）兜底，确保流程不阻塞。

### 4. 承载点策略（anchorPolicy）

合并K线存在“承载点（Anchor）”概念，用于后续标记定位（例如合并K形态落点、涨跌标记等）：

- anchorPolicy = 'right'：
  - anchor_idx_orig = end_idx_orig（取右端承载）
- anchorPolicy = 'extreme'：
  - 若 dir_int > 0（上涨），取最高点来源：anchor_idx_orig = g_idx_orig
  - 若 dir_int < 0（下跌），取最低点来源：anchor_idx_orig = d_idx_orig

**key point 工程对齐**：anchor_idx_orig 不作为 ReducedBar 存储字段；由渲染/算法层按策略动态推导。

### 5. 跳空缺口字段（gap_enum）的判定规则

gap_enum 是合并K线之间“价格区间是否不重叠”的几何判定，独立于任何“开盘-昨收涨跌幅阈值”的连续性屏障概念。

- 对当前合并K线 cur 与上一根 prev：
  - 上跳空：prev.High < cur.Low → gap_enum='up'
  - 下跳空：prev.Low > cur.High → gap_enum='down'
  - 其它：gap_enum='none'
- **key point 判定时机**：在合并操作完成后，对“最新合并K线”与“次新合并K线”进行判定，并把结果记录到最新合并K线。

### 6. 时间字段规范（统一 ts，参与计算的长期存储只用 ts）

- 所有参与计算或需要长期保存于要素结构中的时间字段，统一使用：
  - ts：number（毫秒时间戳，Unix epoch ms）
- 合并K线内部不保存 start_ts/end_ts；需要时可通过 idx_orig 回溯 candles 取 ts。
- **key point 不保存 iso 字符串时间字段**：iso/字符串仅属于展示层需求，按需调用通用工具模块即时转换。

### 7. 关键不变量（回归测试应覆盖）

- 单向扫描：从左到右，任何一根原始K线只被处理一次。
- 不跨岛合并：seq_id 变化处，合并K序列断开。
- 完备分类：每步比较只会进入三类之一：
  - 严格上涨推进（新K入列）
  - 严格下跌推进（新K入列）
  - 其它（包含/重叠 → 按趋势合并到最新合并K）
- 极值来源正确：
  - g_idx_orig/d_idx_orig 必须总是落在 [start_idx_orig, end_idx_orig] 覆盖范围内。
- gap_enum 一致：
  - cur.gap_enum == 'up' ⇒ prev.High < cur.Low 必成立；
  - cur.gap_enum == 'down' ⇒ prev.Low > cur.High 必成立；
  - 二者不可同时成立。

### 8. 建议补充的“思想/成果传递”信息（作为后续维护者的最短路径）

1) 职责边界说明（防止职责漂移）

- 合并K线模块只负责：包含关系处理 + 连续岛切分后的岛内合并 + 结构/几何元数据输出。
- 不负责：分型/笔/线段/中枢识别；不负责展示格式化；不负责后端任务调度。

1) 数据字段“真相源”声明

- 时间真相源：ts（ms）。
- 价格真相源：candles（唯一真相源）；合并K线仅存 idx_orig。

1) 最小可复现示例（建议维护一份）

- 给出 6~12 根原始K（ts + h/l），覆盖：
  - 严格上涨推进
  - 严格下跌推进
  - 含等号的包含（边界贴合）
  - 重心兜底触发（岛开端包含）
  - gap_enum='up' 与 'down'
  - 屏障断岛（seq_id 变化）
以便每次重构都能一键验证。

---

## 分型

默认你在主图上能看到合并K线与分型标记；若没有，也请尽量按“合并K视角”理解与执行。下面是一套面向人工手画与显示层标注的简化、可执行规则。

### 一、准备与统一口径

- **key point 以合并K线为唯一基准**：所有分型判定、强弱分档与确认关系，仅看合并K线的序列与极值。
- **key point 分型的承载点为中柱**：顶分型与底分型均以三根结构中的第二根（中柱）作为定位与标注点。
- **key point 中点的统一定义**：一根合并K线的“中点”是该根最高点与最低点的平均位置。强弱分档统一以第一根的中点为参照。
- **显著度门槛（预留）**：为后续降噪预留“最小价差”与“最小百分比”的门槛设置项，当前默认值为零（不开启筛选）。
- **key point 同时跟踪双向极值**：从最左端开始同步维护“当前最高顶分”与“当前最低底分”，每次出现更极值都立刻修正；避免因“首遇分型”导致起点偏向。

### 二、分型的基本判定（方向序列为第一准则）

- **顶分型（上转下）**：从左到右观察三根合并K线，若第二根表现为上涨、第三根表现为下跌，则判定为顶分型；中柱为定位与标注点。
- **底分型（下转上）**：从左到右观察三根合并K线，若第二根表现为下跌、第三根表现为上涨，则判定为底分型；中柱为定位与标注点。
- **极值标注**：
  - 顶分型以中柱的最高点进行标注；
  - 底分型以中柱的最低点进行标注。
- **共用规则（一般情况）**：
  - **key point 一般允许分型之间共用合并K线**：同一根合并K线可以同时参与多组分型的三根结构，无需强制“非重叠”。

### 三、强弱分档（以三根的极值与第一根中点为准）

- **顶分型的强弱分档**（三根从左到右为第一、第二、第三）：
  - 标准顶分：第三根的最低点位于第一根的最低点与第一根的中点之间（包含两端点）。
  - 弱顶分：第三根的最低点高于第一根的中点（回落力度偏弱）。
  - 强顶分：第三根的最低点低于第一根的最低点（回落力度偏强）。
- **底分型的强弱分档**：
  - 标准底分：第三根的最高点位于第一根的中点与第一根的最高点之间（包含两端点）。
  - 弱底分：第三根的最高点低于第一根的中点（反弹力度偏弱）。
  - 强底分：第三根的最高点高于第一根的最高点（反弹力度偏强）。
- **直觉理解**：顶分型看“第三根跌到哪里”（跌得越深越强）；底分型看“第三根涨到哪里”（涨得越高越强）。

### 四、确认分型（双分型紧邻且严格不等）

- **结构要求**：
  - **key point 必须由连续六根合并K线组成**两个相邻的同向分型：第一组三根与第二组三根紧密相接，正好覆盖六根合并K线。
  - **key point 两个分型之间既不能重叠也不能相离**：不允许共用合并K线；也不允许在两组分型之间夹任何独立合并K线。
- **极值比较（严格不等）**：
  - 同为顶分时：第一组的中柱最高点严格高于第二组的中柱最高点，并且第一组右柱最高点严格高于第二组左柱最高点。
  - 同为底分时：第一组的中柱最低点严格低于第二组的中柱最低点，并且第一组右柱最低点严格低于第二组左柱最低点。
- **结论意义**：满足以上结构与比较关系，视为对前一分型的“确认分型”，提示其更可能是一次转折而非中继。

### 五、常见误区与自检要点（分型专项）

- **一般允许共用**：分型之间一般允许共用合并K线；确认分型必须严格六根且不可共用、不可相离。
- **强弱分档靠位置**：顶分看第三根最低点相对第一根最低点/中点的位置；底分看第三根最高点相对第一根中点/最高点的位置。
- **确认分型严格不等**：仅接受“整体下移/整体上移”的严格不等关系；“相等”不视为确认。
- **显著度门槛先为零**：默认不筛；需要降噪时再启用门槛。

### 六、一个直觉例子（帮助手感）

- 在一段上涨后突然出现“第二根上涨、第三根下跌”的三根结构，即顶分型；第三根的最低点介于第一根的最低点与第一根的中点之间，为“标准顶分型”。
- 紧接着又出现另一组三根“第二根上涨、第三根下跌”，两组共覆盖六根合并K线，中间没有任何独立合并K线，也没有重叠；新的第一根整体低于上一组的第三根（最高点与最低点都更低），新的第二根的最高点也低于上一组的第二根最高点。此时，对第一组构成“确认顶分型”，提示其更可能是转折。

### 七、分型要素字段说明（工程用“数据字典”）

本节定义“分型（Fractal）”要素的字段，供后续模块（笔、线段、中枢、导出、回测等）引用。所有字段均以“合并K线”为基准。

#### 7.1 字段清单（类型/语义）

- kind_enum: 'top' | 'bottom'  
  顶分/底分。
- seq_id: number  
  连续岛编号；分型识别与确认配对均不得跨岛。

- k1_idx_red / k2_idx_red / k3_idx_red: number  
  三根结构中第1/2/3根合并K线的索引（合并K序列下标）。
- k2_idx_orig: number  
  承载点对应的原始K线索引（顶分取中柱 g_idx_orig；底分取中柱 d_idx_orig）。

- strength_enum: 'strong' | 'standard' | 'weak'  
  强弱分档结果。

> **key point 工程对齐**：Fractal 本体严格 Idx-Only，不保存价格/时间字段；价格与时间均通过 idx_orig 回溯 candles 读取。

- 确认分型配对：以派生结构 confirmPairs 表达（不污染 fractals）：
  - confirmPairs.pairs: Array<{a:number,b:number,kind_enum:'top'|'bottom',seq_id:number}>
  - confirmPairs.paired: boolean[]（与 fractals 等长）
  - confirmPairs.role: Array<'first'|'second'|null>（与 fractals 等长）

#### 7.2 时间字段使用规范（仅存 ts，不在算法模块做格式化）

- 若需要按交易日对齐：使用 timestampToYYYYMMDD(ts)。
- 若需要按频率展示：展示层使用 formatTimeByFreq(freq, ts)。
- 若需要展示到分钟：展示层使用 parseTimeValue(ts) + formatDateTime(date, true)。
- 分型识别模块内部不做字符串格式转换，不保存 ISO 字符串字段。

### 八、分型识别算法（工程可执行版）

#### 8.1 基础识别（允许共用合并K线）

对每个连续岛（seq_id）独立扫描，按合并K索引从左到右取窗口 (K1,K2,K3)：

- 顶分型：
  - 若 K2.dir_int > 0 且 K3.dir_int < 0，则产生顶分型，承载点=K2，标注价=K2.High（由 g_idx_orig 回溯）。
- 底分型：
  - 若 K2.dir_int < 0 且 K3.dir_int > 0，则产生底分型，承载点=K2，标注价=K2.Low（由 d_idx_orig 回溯）。

扫描步长为 1，因此分型之间天然可能共用合并K线（一般情况允许）。

#### 8.2 强弱分档（严格口径）

设第一根为 K1，第三根为 K3，K1 中点 M1=(H1+L1)/2：

- 顶分（看 K3 的最低点 L3）：
  - 强：L3 < L1
  - 弱：L3 > M1
  - 标准：L1 ≤ L3 ≤ M1（含边界）
- 底分（看 K3 的最高点 H3）：
  - 强：H3 > H1
  - 弱：H3 < M1
  - 标准：M1 ≤ H3 ≤ H1（含边界）

#### 8.3 确认分型配对（六根合并K，紧邻且严格不等）

- 结构约束：第二组必须紧接第一组的右柱之后：
  - 若第一组为 [A1,A2,A3]，则第二组必须为 [B1,B2,B3] 且 B1.idx_red = A3.idx_red + 1。
- 极值严格不等：
  - 顶分确认：A2.high > B2.high 且 A3.high > B1.high（严格）
  - 底分确认：A2.low < B2.low 且 A3.low < B1.low（严格）
- 工程实现允许“保守增强”：在不违背上述最小充分条件的前提下，可增加额外约束以减少误配对；若实现比本节更严格，需在代码注释中明确写出“增强条件”，保证口径可追溯。

---

## 笔

默认你在主图上能看到合并K线与分型标记；若没有，先将有包含关系的K线做合并处理，并完成分型识别与标记，再执行画笔操作。下面是一套面向人工手画笔的简化操作法（自然语言，面向实际手工标注）。

### 一、准备与统一口径

- **key point 以合并K线为基准判断间距**：所有间距与跨度判断都看合并K线，不看原始K线根数。
- **key point 分型的承载点=中柱**：顶/底分型均以其三根结构的中柱作为定位点。
- **key point 最小净间距阈值为3**：两次分型“承载点”的净间距（不含起止点）达到3，才允许成笔。直觉理解：两个分型之间，至少要有一根“既不属于前一分型窗口、也不属于后一分型窗口”的独立合并K线。
- **key point 端点必须是反向分型**：上行笔“底→顶”，下行笔“顶→底”，两端均为分型定位点。
- **key point 区间内严禁出现更大的极值**：对上行笔，区间内不得有“更低的底”或“更高的顶”；对下行笔，区间内不得有“更高的顶”或“更低的底”。一旦出现，必须立刻修正端点。
- **key point 首尾相连不变量**：上一笔的终点与下一笔的起点始终是同一个点；任何修正都必须同步维护这一不变量。
- **key point 相等不算“更大”**：只当“更高/更低”严格成立时才视为“更大极值”，相等不触发修正。
- **key point 没有“确认/预备”状态**：所有笔都可能因为后续极值而被修正，因此只需一直画到全量数据范围内能成立的最后一点为止。
- **key point 首笔同时跟踪双向极值**：首笔从最左端开始同步维护“当前最高顶分”与“当前最低底分”，每次出现更极值都立刻修正；避免因“首遇分型”导致起点偏向。

### 二、成笔“三硬条件”（必须同时满足）

1) 端点类型：起止点必须互为反向分型  

   - 上行笔：起点=底分型，终点=顶分型。  
   - 下行笔：起点=顶分型，终点=底分型。

2) 最小间距：两分型承载点的合并K净间距 ≥ 3  

   - 记法：间距 = 终点承载点rid − 起点承载点rid ≥ 4（等价于“含端点K线数”≥ 5），以“|idxTop - idxBottom| ≥ 4”表达。。

3) 极值排他：起止点之间“开区间”内不允许出现“比起止点更大的极值”  

   - 极值要比较的是顶分型的G点价格或底分型的D点价格。
   - 上行笔：区间内不得出现“底更低于起点底”或“顶更高于终点顶”。  
   - 下行笔：区间内不得出现“顶更高于起点顶”或“底更低于终点底”。

备注：任一条件不满足即不可成笔；若后续出现“更大极值”，需立即修正相应端点，再重查三条件。

### 三、画笔的人工操作法

按时间从左到右，同时跟踪顶分与底分两条“极值轨”：

1) 同步维护两端候选  
   - 自全量数据最左端起，同时维护“当前最高的顶分”和“当前最低的底分”，横坐标为顶底分型极值对应的合并K线横向位置，纵坐标为极值价格。  
   - 每当出现更极值（更高顶/更低底），立即修正对应一端的候选极值。

2) 第一笔的确定
   - 最初顶底两端候选均为空，分别把第一次遇到的顶底分型缓存至对应缓存器做为第一轮候选，一旦两端都已有候选分型（顶与底同时存在），立刻触发第一次间距检查（不含起止点的净距 ≥ 3）。
   - 如间距不满足则继续向右检索分型并做极值修正，任意一端发生修正时都立即再次触发间距检查。
   - 如间距满足成笔条件则第一笔成立，并根据此时的顶底分型位置确定起止点和笔方向。如顶分型在左则为下行笔（起点为顶分，终点为底分），如底分型在左则为上行笔（起点为底分，终点为顶分）。
   - 提示：第一笔的方向不做预设，由“起点分型与终点分型的组合”自然决定。

3) 起笔后的继续检索  
   - 第一笔落定后，把第一笔终点做为下一笔起点（各笔严格“首尾相连”），把下一笔终点缓存清空，从起点继续向右检索分型。
     - 后续各笔的方向均已随第一笔方向的确定而确定（必然是上行笔与下行笔交替出现，不可能连续出现同向笔），各笔起止点的分型方向也随当前笔方向确定而确定且交替改变。
     - 检索到的分型应严格与当前笔起止点的分型方向相对应，上行笔时起点只与底分比对是否修正，终点只与顶分比对，下行笔时起点只与顶分比对是否修正，终点只与底分比对，确保起止点的分型方向在每一笔中稳定不变且保持反向，后续在判断成笔条件时就不必再专门校核分型方向。

4) 后续笔的极值修正
   - 每当任一端出现更极值（如终点为空，把遇到的第一个与起点分型方向相反的分型缓存为终点，后续再做极值修正），先修正端点，再验成笔条件。
     - 当终点被更极值修正时，影响范围仅在当前笔，检索过程中已经通过约束条件保证了起止点分型方向相反，且通过极值修正始终保持每一笔内起止点都是极值，所以在检验成笔条件时只需要检验起止点间距即可。
     - 当起点被修正时，因前一笔终点也被同步修正了，首先要核检前一笔的起点是否需要修正（修正前的原终点到修正后的新终点之间是否出现了与原起点方向相同且更极值的分型），如前一笔的起点也被修正，则再向前追溯一笔核检前前一笔的起点是否需要修正，一直向前追溯到某一笔的起点无需修正为止，方可判定已充分修正到位。
   - 向左追溯稳定后，从稳定后的那一点开始向右逐笔校核起止点间距是否满足成笔条件（合并K净距≥3），如满足则确认该笔然后继续向右检核，如不满足则从该笔开始按统一规则重画后续各笔。
     - 不满足成笔条件包括两种情况：1. 间距不足；2. 终点为空的情况。
       - 终点为空可能因以下两种原因之一导致：1. 因起点修正右移而越过了原终点导致原终点失效清空，2. 原有各笔已检核完成来到新一笔即终点为空。
       - 如为间距不足则以当前笔的现存起点终点为现状继续向右检索画笔，如为终点为空则从起点开始继续向右检索画笔。
5) 按上述规则3、4循环往复，成笔后以前一笔终点做为下一笔起点继续向右检索，遇更极值立即修正，遇起点修正立即向左追溯检核，追溯稳定后重新向右检核、检索，直至本连续岛或全量数据检索完成。

### 四、现场修正与连锁回溯（遇更大极值怎么办）

遇到更大极值时，务必先修正极值（端点），再判断间距与区间极值是否合规：

1) 终点被更大极值替换：  

   - 立即重查“三硬条件”。若不满足，继续向右；满足则保持当前笔。

2) 起点被更大极值替换（起点右移）：  

   - 同步把“上一笔的终点”一起右移到该新起点（保持首尾相连）。  
   - 随即检查“上一笔”的区间是否被更大极值破坏：若是，上一笔的起点也要相应右移；并继续向更早的笔回溯……直到最早需要修正的那一笔也恢复合法（其区间内不再有“更大极值”）。  
   - 若本笔“起点右移后落到终点右侧”，则“终点立即失效清空”，待回溯稳定后，从新起点往右重新逐笔检核已有后续各笔的起止点是否满足成笔条件，如满足则继续向右逐笔检核，直至某一笔终点不满足或为空，则以此笔现状为起点开始重新画笔，右端原有各笔全部作废重画。

3) 修正优先级与尺度：  

   - 只要发现“更大极值”，先改端点，再查三条件；宁可多次小步修正，也不提前“凭间距成笔”。  
   - “相等”不视为更大，不触发修正。

### 五、笔的终止与数据边界

- 当因除息等原因导致K线连续性被破坏（断裂阈值按相邻交易日涨跌幅 > 静态阈值），则以断裂点为边界将全量数据切分为若干连续岛，画笔以断裂点为边界，确保笔不跨界。后续线段、中枢等均以笔为基础，因此线段、中枢也限制在连续岛内不跨界。
- 分岛规则如下：
  1. 使用相邻原始K作比对而不使用合并K；
  2. 使用静态阈值而不使用动态阈值（因改用原始K而限制了时间跨度为相邻交易日，无需考虑跨多日的情况），静态阈值建议为50%（各类标的包络考虑）；
  3. 排除新股上市前10日（前5日无涨跌幅限制），即默认前10个交易日为连续，从第11个交易日开始做比对（第10个原始K和第11个原始K比对）
  4. 涨跌幅比例算法：（当日H-前日C）的绝对值/前日C，（前日C-当日L）的绝对值/前日C。该两个比值中任意一个大于等于静态阈值则判定分岛，小于静态阈值则判定为连续。
- 一直自左向右画，直到连续岛或全量数据的最右端。遇连续岛界则终止当前连续笔，下一连续岛内重新起笔。
- 最后一笔：以数据右端为止，能满足“三硬条件”的最后一笔为终点；如果后续再出现“更大极值”，可继续修正并延伸。
- 不存在“确认/预备”之分，因后续仍可能修正。  

### 六、对称规则与判定口令

- 起止反向，净距够三，端点极值，落笔可变。
- 任何时刻：**先修极值，再验三条（反向/间距/无内极值），再落笔。**

### 七、操作小贴士与避坑清单

- **key point 先极值后间距**：绝不能“先看间距成笔、再修极值”；遇更大极值必须先改端点。  
- **key point 相等不作大**：相等不触发修正，避免无意义抖动。  
- **key point 开区间检查**：极值排他只看“起止之间”的开区间，不含两端。  
- **key point 首尾相连**：任何修正都同步维护“上一笔终点 = 下一笔起点”。  
- **key point 起点越过终点立即清空终点**：先稳定起点与回溯，再从新起点右侧重找终点。  
- **key point 看合并K不是看原始K**：计数与间距全部以合并K为准。  
- **key point 没有“最终确认”**：只需在当前数据区间内做到最后一笔满足即可，后续数据会继续触发修正。

### 八、可视检查清单（每笔必做“三问”）

1) 端点是不是“互为反向的分型承载点”？  
2) 两端承载点间距是否≥4（等价含端点根数≥5）？  
3) 两端之间是否没有更大的极值（上行：无更低底/更高顶；下行：无更高顶/更低底）？

若全部“是”，这笔当前成立；否则继续修正/检索。

### 九、术语速查与计数口径

- 合并K线：包含关系处理后的K线，作为唯一计数单位。  
- 分型承载点：三柱分型的中柱位置，用于定位起止端点。  
- 更大极值：上行看“更低的底 / 更高的顶”，下行看“更高的顶 / 更低的底”；严格不等。  
- 间距=4：指“终点承载点rid − 起点承载点rid ≥ 4”；等价“含端点K线数≥5”。  
- 开区间检查：只在起止承载点之间的内部检查是否出现更大极值；两端不算入内部。

用这套规则“看左打底、看右封顶；遇强者从之、修后再验；三条皆成，笔乃暂立；首尾相连，画至最末”。在实际标注中，始终坚持“先修极值、再验三条”的顺序，就能稳定地得到一致可复核的手工笔。

---

## 线段

### 0. 定义与边界（先说清楚我们在做什么）

- 线段是比“笔”更高一级的走势结构，用来把一段走势用更少、更清晰的折线表达出来。
- 线段只在同一个**连续岛（seq_id）**里工作：岛内画线段，岛外重新开始。任何线段都不跨岛。
- 线段最终画出来应该是一条**连续折线**：后一段的起点必须和前一段的终点是同一个点（横轴 idx_orig 共点）。

### 1. 元线段与成立线段（两层结构）

为方便理解，我们把线段分成两层：

1) **元线段**（也可以理解为“线段片段”）  
   - 这是算法先算出来的“原始线段片段”，往往是断裂的、不一定能直接一段段连成折线。
   - 每条元线段初始状态都叫“待成立”。

2) **成立线段**  
   - 元线段经过“连接规则”处理后，变成连续折线的一段，并被确认“成立”。
   - 一旦某段线段被确认成立，它的终点就锁死（不会再改），它就正式成为最终折线的一部分。

### 2. 两种缺口：外部缺口 vs 内部缺口（不要混）

1) **外部缺口**（线段之间是否断开）  
   - 看两段线段 A、B 是否“端点共点对齐”：
     - 如果 A 的终点 idx_orig == B 的起点 idx_orig：外部无缺口，AB 连上了。
     - 否则：外部有缺口，AB 断开了。
   - **key point 判定口径**：外部缺口只看 idx_orig 是否共点。你已确认，不看时间戳，不看价格区间。

2) **内部缺口**（单条线段内部结构是否紧凑）  
   - 内部缺口用来判断“这一段线段内部是否存在结构性断裂”，它不靠“线段之间是否连上”来判断。
   - 内部缺口的规则已经在 v1.2 中定义：特征序列 → 先消解包含 → 最右两条有效特征序列判定。这里不再重复展开，只强调它的触发时机：  
     **key point 只要 AB 连上了（外部无缺口），就立刻对前段 A 做内部缺口判断。**

### 3. “更极值”比较：到底比哪个价、怎么比（你已确认的口径）

连接规则里出现“更极值”，说的就是：**比较相邻两条线段的相邻端点价**。

- 比较对象永远是**端点**，不是中间任何东西。常见就是比：
  - A 的终点 vs B 的起点（反向且有外部缺口时）
  - 或 B 的终点 vs A 的终点（同向且有外部缺口时，用来判断是否创新高/新低）

端点价格的取值非常简单，只看该端点 idx_orig 对应的原始K线 candles 的 h/l：

- **上涨线段（UP）**
  - 起点价 = candles[start_idx_orig].l
  - 终点价 = candles[end_idx_orig].h
- **下跌线段（DOWN）**
  - 起点价 = candles[start_idx_orig].h
  - 终点价 = candles[end_idx_orig].l

举例：  
A 上、B 下，要比较 A 终点和 B 起点谁更极值，那就是比较谁更高，并且：

- A 终点价 = candles[A.end_idx_orig].h
- B 起点价 = candles[B.start_idx_orig].h

### 4. 连接规则的几条铁律（强约束，任何情况都必须遵守）

1) **A 的起点永远锁死**  
   - 你在处理一对线段时，前段叫 A，后段叫 B。
   - 无论发生什么，A 的起点都不允许变化。  
     能改的只有：
     - A 的终点（必要时对齐）
     - B 的起点（必要时对齐）
     - 或同向合并时“用更远的终点扩展 A”（但起点仍不动）

2) **只要 AB 连上了，就立刻对 A 做内部缺口判断**  
   - 一旦 A.end.idx_orig == B.start.idx_orig（无论是天然连上，还是规则对齐后连上），就马上判断 A 是否有内部缺口：
     - 若 A 无内部缺口：A 立即确认成立，锁死 A 终点（同时 B 起点也因此锁死）。
     - 若 A 有内部缺口：A 暂不确认，继续往右推，直到出现下一次“反向连接成功”，那一刻 A 立刻确认成立（见第 6 节）。

3) **连接只在同一连续岛内进行**  
   - 到了岛的最右端，岛内再没有更多线段可用了：只能把“已完成连接但还没确认的最后一段”直接确认成立（见第 7 节）。

### 5. 元线段连接的总体操作方式（人能执行的版本）

你可以把连接过程理解为：  
**从左到右拿两段线段当成一对（A、B）来处理**，处理完再往右走，直到把整个岛内的线段折线连起来。

具体做法：

- 在一个连续岛内，从最左第一条元线段开始，记为 A（待成立）。
- 向右找到它后面的下一条元线段，记为 B。
- 观察 A 和 B 的关系，只有两类情况需要处理（与你原始规则一致）：
  1) A、B **反向**
  2) A、B **同向**且有外部缺口  
     （你已确认：同向且无外部缺口不可能出现，所以不用讨论）

然后按下面规则执行。

---

### 6. 三种主情况（按你原始规则的自然语言顺序）

#### 情况 1：A、B 反向，且 AB 端点已经共点对齐（外部无缺口）

这就是最理想的连接情况：AB 已经连上了。

接下来立刻做一件事：  
**判断 A 的内部缺口**（规则另详）。

- **1.1 若 A 内部无缺口**  
  - A 立即确认“成立”，锁死 A 的终点（因此 B 的起点也锁死）。
  - 然后把 B 作为新的前段 A，继续向右找下一段，重复本章规则。

- **1.2 若 A 内部有缺口**  
  - A、B 都先保持“待成立”，先别确认。
  - 继续向右再找下一条元线段 C，用来观察 B 与后续的关系（见“情况 1.2 的后续处理”）。

##### 情况 1.2 的后续处理：A 已连上 B，但 A 内部有缺口，继续往右推

你要做的是：继续向右推，直到 B 和后面某一段形成“反向且连上”（无论天然连上还是规则对齐后连上）。一旦 B 反向连上成功，就立刻确认 A。

往右看下一条线段 C 后，会出现两类分支：

- **1.2.1 如果 B 和 C 同向，且 C 的起点是更极值**  
  - 直接忽略 B（把 B 当成噪声或趋势里不重要的小插曲）。
  - 接下来把“要处理的对象”改为 A 和 C（不再管 B）。
  - 然后看 A 与 C 的关系：
    - 如果 A 与 C 同向且有外部缺口 → 按“情况 2”的规则处理；
    - 如果 A 与 C 反向且有外部缺口 → 按“情况 3”的规则处理；
    - 如果 A 与 C 反向且无外部缺口 → 回到“情况 1”（因为已经连上，要判断内部缺口并推进）。

- **1.2.2 如果 B 和 C 同向，但 C 起点不是更极值**  
  - 说明 B 还有继续参与趋势演化的价值，不能直接丢掉。
  - 这时先按“情况 2”的同向规则去处理 B 和后续的线段（可能会发生同向合并扩展，或忽略某些小段）。
  - 不管你迭代了多少步，不管中间 B 是否已经被替换成“新的 B”，只要最终出现“B 与后续某段反向并且连上了”（无论天然连上还是规则对齐后连上），就在那一刻：
    - A 立即确认成立；
    - 并且因为此时 B 也完成了反向连接，所以立刻对 B 做内部缺口判断（进入与 A 同样的流程循环）。
  - 然后继续向右推进。

---

#### 情况 2：A、B 同向，且 AB 有外部缺口

这种情况本质是：趋势同方向延续，但中间断开了，B 是否值得纳入“更大线段”要看它有没有形成新极值。

你要做的就是比较：**B 的终点相对 A 的终点是否创了新极值（严格不等）**。

- **2.1 若 B 终点相对 A 终点创出新极值（严格不等）**  
  - 上涨同向：B 终点更高（创新高）  
  - 下跌同向：B 终点更低（创新低）
  - 处理：把 A 的起点（锁死不变）与 B 的终点连接，形成一个“新的更长线段 A”（仍是待成立）。
  - 然后用这个新 A 继续向右找下一段。

- **2.2 若 B 终点没有创出新极值**  
  - 处理：忽略 B，直接跳过它继续向右。  
  - 直觉解释：这种同向但不创新极值的线段，要么是趋势里的小插曲，要么是转折后的小波动，都会被淹没在趋势中，不必计入主线段折线。

---

#### 情况 3：A、B 反向，且 AB 有外部缺口

这种情况是：方向反了，但断开了，需要把它们“对齐端点”强行连接起来。

步骤：

1) 比较 A 的终点与 B 的起点谁为更极值（严格不等优先）  
   - A 上 B 下：看谁更高  
   - A 下 B 上：看谁更低

2) 分支处理：

- **3.1.1 若 A 终点为更极值**  
  - 把 B 的起点对齐到 A 的终点，让 AB 连上（B 起点改成 A 终点那根 idx_orig）。
  - AB 连上后，立刻回到“情况 1”（因为反向且无外部缺口），对 A 做内部缺口判断。

- **3.1.2 若 B 起点为更极值**  
  - 把 A 的终点对齐到 B 的起点，让 AB 连上（A 终点改成 B 起点那根 idx_orig）。
  - 注意：A 起点仍然锁死不变。
  - AB 连上后，立刻回到“情况 1”，对 A 做内部缺口判断。

- **3.1.3 若比较结果相等（A 终点价 == B 起点价）**（你已给定兜底口径）  
  - 以先出现为准：保持 A 终点不变。
  - 用 B 起点向 A 终点对齐，让 AB 连上。
  - 然后回到“情况 1”，对 A 做内部缺口判断。

---

### 7. 岛末尾如何收尾（自动成立的精确定义）

连接只能在同一连续岛内进行。你在岛内从左到右推进时，会不断出现“已完成连接但仍待确认”的线段（因为内部缺口可能让它延迟确认）。

当你推进到了岛的最右端，岛内已经没有更多线段可用时：

- 只能对“**已完成连接但待确认**”的最后那一段线段直接确认成立。
- **key point 与是否元线段无关**：最后被确认的线段可能已经不是元线段，可能在连接过程中因为同向合并或端点对齐而变长/变形；只要它是“完成连接后仍待确认的那一段”，就确认它。

---

### 8. 绘制口径（最终画在图上的线段怎么取点）

每条成立线段画成一条直线段，连接其起点与终点：

- 上涨线段（UP）：
  - 起点 y = candles[start_idx_orig].l
  - 终点 y = candles[end_idx_orig].h
- 下跌线段（DOWN）：
  - 起点 y = candles[start_idx_orig].h
  - 终点 y = candles[end_idx_orig].l

成立线段按顺序首尾相接，形成完整的线段折线（因为已经保证相邻段端点 idx_orig 共点）。

---

## 中枢（笔中枢）

面向人工标注与复核的“笔中枢”操作规则。默认你已完成合并K与“成笔”（严格首尾相连）的识别；若没有，应先完成“笔”的构建，再在此基础上识别并绘制中枢。

### 一、准备与统一口径

- **key point 以“笔”为唯一计量单位**：所有判定与扫描均以“笔”的顺序与价格范围进行，不再回看原始K或分型细节。  
- **key point 中枢是“价格重叠+进出”之组合**：先看连续四笔是否在价格区间上形成重叠，再校验进入与退出的约束。  
- **key point 零厚度不成立**：中枢上下沿必须严格有宽度（上沿 > 下沿）；“上沿=下沿”不判定为中枢。
- **key point 四笔滑窗检索**：遵循"四笔滑窗"原则逐次检索，如P1-P4窗口判定失败，则继续对P2-P5窗口判定，以此类推。  
- **key point P3无需单独约束**：笔严格首尾相连，P3 的起止自然由 P2 与 P4 的终起决定；对 P2、P4 施加的约束已隐含覆盖 P3。  
- **key point 判定价格口径统一**：一笔的“端点价格”直接取该笔的两个端点（起点价、终点价），不做二次推导，以避免口径分歧。

### 二、基本判定要素（四笔滑窗检索）

以连续四笔 P1、P2、P3、P4 组成一个检测窗口检核“是否形成笔中枢”的必要与充分条件如下：

1) 价格重叠区（由 P2、P4 决定）

   - 取 P2 与 P4 的“上界”“下界”：  
     上界 upper = min(P2 最高端点价，P4 最高端点价)  
     下界 lower = max(P2 最低端点价，P4 最低端点价)  
   - **必要条件**：upper > lower（严格大于）。否则“零厚度”，不成立。

2) 进中枢的一笔（P1 的外部性约束）

   - **key point P1 起点必须在 P2–P4 的整体包络范围之外**：  
     设 P2–P4 包络 = [min(P2 最低端点价，P4 最低端点价)，max(P2 最高端点价，P4 最高端点价)]，  
     则 P1 起点价 must 满足：  
     (P1 起点价 > max(P2 最高端点价，P4 最高端点价)) 或 (P1 起点价 < min(P2 最低端点价，P4 最低端点价))。  
     换言之，P1 起点必须完全在“P2 和 P4 的最外层包络”之外（严格不等）。

3) 四笔重叠（直觉解释）

   - P2 与 P4 决定了一个“重叠价格带”[lower, upper]；这表示“中枢的核心区间”。  
   - P1 负责“从外部进入”这个价格带（见上条“外部性”）；P3 在笔首尾相连前提下自然穿越或邻接该带，无需额外条件。  
   - **key point 只要 1)+2) 满足，即视为形成“第一段笔中枢”**（P1–P4）。

4) 中枢方向（阶段性）

   - **key point 方向按 P1 所属方向确定**：  
     P1 上行 → 上涨中枢；P1 下行 → 下跌中枢。  
     如后续有更完备定义，可在此基础上替换。

### 三、成中枢与延续的判定

- 成立起点（左沿）：中枢一旦由 P1–P4 判定成立，**左沿**取 P1 的“终点”横坐标。  
- 延续规则（从 P5 开始逐笔向右检核）：

  - **key point 跨越也视为“在中枢内”**：只要该笔的价格区间与 [lower, upper] 有交集（包括端点相等），即视为“仍在中枢范围内”。  
  - **key point 中枢结束的唯一条件**：出现“完全在外的一笔”——该笔的起点与终点价同时高于上沿，或同时低于下沿（严格不等）。  
  - 结束位置（右沿）：以“首根完全在外的那一笔”的“起点”为**右沿**横坐标。  
  - 若直至本连续段最末也未遇到完全在外，则**右沿**取“该连续段最后一笔的终点”。

- 连续多个中枢：当一个中枢结束后，**从“中枢内最后（右）一笔”重新作为新的 P1**，按同样逻辑继续向右检索，直至本连续段右端。

### 四、扫描策略与不跨岛的约束

- **key point 只在同一“连续岛/连续段”内识别**：笔不跨连续岛，笔中枢也因此天然不跨岛。  
- 扫描顺序：自左向右，按（P1，P2，P3，P4）滑动窗口逐一检测；第一个中枢落定后，从 P5 开始延续；结束后从“完全在外的第一笔”起生成下一组窗口（P1–P4），继续检测。

### 五、边界与等号规则

- **key point 上下沿严格不等**：upper > lower 是成立中枢的必要条件，“等于”不成立。  
- **key point 延续时的交集是闭区间**：任一端点“等于上下沿”视为“仍在中枢范围内”（不判为结束）。  
- **key point 结束的“完全在外”是严格不等**：端点都“严格高于上沿”或都“严格低于下沿”，才视为中枢结束。

### 六、左右沿与几何边界（可视化定位口径）

- 左沿（时间轴）：P1 的“终点”时刻（或位置）。  
- 右沿（时间轴）：首根“完全在外的一笔”的“起点”时刻（或位置）；若无，则取“本连续段的最后一笔的终点”。  
- 上沿（价轴）：min(P2 的最高端点价，P4 的最高端点价)。  
- 下沿（价轴）：max(P2 的最低端点价，P4 的最低端点价)。

### 七、显示与样式建议（不影响判定）

- **key point 形状用“矩形框”表达**：以[左沿，右沿]×[下沿，上沿]构成的矩形表示一个中枢。  
- 边框与填充：  
  - 边框线型默认实线，线宽建议 1.5；上涨/下跌使用区分色（如红/绿）。  
  - 填充色直接引用边框色，并以透明度淡显（如 5%），确保观感与边框一致、但不遮挡主体。  
- 层级：可将中枢框的显示层级置于“笔之上、屏障之下”，保证可读性（例如中间层级）。  
- 多个中枢：按时间排列，互不干扰，各自画框。

### 八、术语与口径说明

- **笔的端点价**：指该笔的“起点价”“终点价”两者之一，即笔本身输出的两个端点价格。  
- **最高/最低端点价**：以该笔两个端点价中的“较高者/较低者”为该笔的“最高/最低端点价”。  
- **价格交集**：两段价格区间在垂直价格轴上有重叠（含端点相等）即视为“有交集”。  
- **P2–P4 整体包络**：指由 P2 与 P4 的端点价所形成的最外层包络区间：[min(P2 最低端点价，P4 最低端点价)，max(P2 最高端点价，P4 最高端点价)]。  
- **P1 的外部性**：P1 起点价严格落在上述“整体包络”之外（大于其上界或小于其下界）。

### 九、人工操作法（复核流程）

1) 从连续段最左端开始，顺序取四笔（P1–P4）做为一组：  
   - 先算 P2、P4 的上下沿（upper、lower），严格要求 upper > lower；  
   - 再检 P1 起点是否在 P2–P4 的整体包络之外（严格不等）：  
     (P1 起点价 > max(P2 最高端点价，P4 最高端点价)) 或 (P1 起点价 < min(P2 最低端点价，P4 最低端点价))。  
   - 若两者都满足，则中枢成立；左沿= P1 终点，方向= P1 方向。

2) 从 P5 开始逐笔检核延续：  
   - 若“该笔区间”与 [lower, upper] 有交集（含端点等于），则延续；  
   - 若“起止点同时在上沿之上或同时在下沿之下”（严格不等），则中枢结束，右沿 = 该笔的起点。

3) 结束后以“中枢内最后（右）一笔”作为新 P1，回到步骤 1。

### 十、常见误区与避坑清单

- **key point 把“P1外部性”写成“在中枢高度范围外”是错误的**：应为“在 P2–P4 整体包络范围外”，即更严格的“在 P2、P4 的最外层包络之外”。  
- **key point 忽略零厚度检查**：upper=lower 不成立。  
- **key point 把“跨越”误判为“在外”**：跨越中枢是“与中枢相交”，属于“在内”，不是结束条件。  
- **key point 试图让中枢跨岛**：笔不跨岛，中枢天然不跨；扫描每个连续段独立完成。  
- **key point 偏离“端点价格=笔输出的两个端点”**：不要回到低层细节重算，口径必须唯一。

---

用以上规则识别与绘制“笔中枢”，即可在“有笔的前提下”稳定抽取一系列矩形框，直观标识出价格在笔层面上的“缠论中枢活动区”。若后续你要扩展“线段中枢”，可以直接沿用“四元素：外部性、重叠、延续、结束”的骨架，替换“笔”为“线段”及相应的价格口径，即可无缝迁移。
